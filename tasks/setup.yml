---
# role: packages
# file: tasks/setup.yml
#
# Tasks to setup packages.
# Each task should be clearly named, with no inventory variable in the name.


# Run debconf BEFORE apt, so packages are preseeded if not yet installed.
- name: "configure packages"
  debconf:
    name:     "{{ pkg.name }}"
    question: "{{ pkg.question }}"
    unseen:   "{{ pkg.unseen | default(omit) }}"
    value:    "{{ pkg.value  | default(omit) }}"
    vtype:    "{{ pkg.vtype  | default(omit) }}"
  register: debconf
  loop: |
    [ {% for p in packages__list if p.debconf is defined %}{% for d in p.debconf %}
      {% if d.name is defined %}{{ d }}{% else %}{{ d | combine({"name": p.name}) }}{% endif %}
      {{ '' if loop.last else ',' }}{% endfor %}{{ '' if loop.last else ',' }}{% endfor %} ]
  loop_control:
    loop_var: pkg


# Don't install all packages at once, to keep trace of atomic changes and use
# them to build the list of packages to dpkg-reconfigure right after. Anyway,
# the name attribute can be a list as well, in this case the list will be
# installed at once.
- name: "install packages"
  apt:
    name: "{{ pkg }}"
    state: "{{ 'latest' if packages__state is defined and packages__state == 'latest' else 'present' }}"
    allow_unauthenticated: "{{ packages__allow_unauthenticated | default(omit) }}"
    autoclean:             "{{ packages__autoclean             | default(omit) }}"
    autoremove:            "{{ packages__autoremove            | default(omit) }}"
    cache_valid_time:      "{{ packages__cache_valid_time      | default(omit) }}"
    default_release:       "{{ packages__default_release       | default(omit) }}"
    dpkg_options:          "{{ packages__dpkg_options          | default(omit) }}"
    force:                 "{{ packages__force                 | default(omit) }}"
    force_apt_get:         "{{ packages__force_apt_get         | default(omit) }}"
    install_recommends:    "{{ packages__install_recommends    | default(omit) }}"
    only_upgrade:          "{{ packages__only_upgrade          | default(omit) }}"
    policy_rc_d:           "{{ packages__policy_rc_d           | default(omit) }}"
    update_cache:          "{{ packages__update_cache          | default(omit) }}"
    upgrade:               "{{ packages__upgrade               | default(omit) }}"
  register: apt
  loop: "{{ packages__list | json_query('[*].name') }}"
  loop_control:
    loop_var: pkg


# Reconfigure packages for which debconf is changed and apt status is not (as
# previously installed or updated packages have already applied debconf config
# in the same time).
- name: "dpkg-reconfigure packages"
  command: "dpkg-reconfigure --frontend=noninteractive {{ pkg }}"
  changed_when: true
  loop: "{{ reconfigure | unique }}"
  loop_control:
    loop_var: pkg
  vars:
    debconf_changed: |
      [ {% for r in debconf.results if r.changed %}
        "{{ r.invocation.module_args.name }}"{{ '' if loop.last else ',' }}{% endfor %} ]
    apt_changed: |
      [ {% for r in apt.results if r.changed %}
        {{ r.invocation.module_args.package }}{{ '' if loop.last else ',' }}{% endfor %} ]
    reconfigure: "{{ debconf_changed | difference(apt_changed|flatten) }}"
